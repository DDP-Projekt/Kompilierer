[
	Pfad Manipulationsfunktionen. NUR FÜR UNIX!
]


Binde "Duden/Texte" ein.
Binde Betriebssystem und Arbeitsverzeichnis aus "Duden/Laufzeit" ein.

[
	Gibt den Pfad-Trennzeichen, der dem Betriebssystem entspricht zurück.
	Auf Linux: '/'
	Auf Windows: '\'
]
Die öffentliche Funktion Trenn_Zeichen gibt einen Buchstaben zurück, macht:
	Wenn das Betriebssystem gleich "Windows" ist, gib '\\' zurück.
	Gib '/' zurück.
Und kann so benutzt werden:
	"Pfad-Trennzeichen",
	"den Pfad-Trennzeichen",
	"das Pfad-Trennzeichen"

[
	Gibt zurück ob der gegebene UNIX Pfad ein absoluter oder relativer Pfad ist
]
Die öffentliche Funktion Ist_Absolut mit dem Parameter t vom Typ Text, gibt einen Wahrheitswert zurück, macht:
	Gib wahr, wenn '/' am Anfang von t steht zurück.
Und kann so benutzt werden:
	"<t> ein Absoluter Pfad ist"

[
	Säubert/Normalisiert einen UNIX Pfad:
	- Ersetzt mehrere aufeinderfolgende '/' durch einen ("///" -> "/")
	- Entfernt '.' pfade ("a/." -> "a")
	- Entfernt innere '..' pfade und das (nicht-..) element das davor steht ("a/b/.." -> "a")
	- Entfernt .. elemente die nach root stehen ("/.." -> "/")

	Der gesäuberter Pfad endet mit einem '/' nur wenn es root ist.
	Ein leerer Pfad gibt "." zurück.

	Entspricht Go's path.clean funktion
	https://pkg.go.dev/path#Clean
]
Die öffentliche Funktion Säubern mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Wenn t gleich "" ist, gib "." zurück.
	Der Wahrheitswert rooted ist wahr, wenn t an der Stelle 1 gleich '/' ist.
	Die Zahl n ist die Länge von t.
	Der Text path ist "". [ output text ]
	Die Zahl r ist 1. [ next index to process ]
	Die Zahl dotdot ist 1. [ index where .. must stop ]
	Wenn rooted gleich wahr ist, dann:
		Füge '/' an path an.
		Speichere 2 in r.
		Speichere 2 in dotdot.

	Solange r kleiner als, oder n ist, mache:
		[Schreibe r auf eine Zeile.]
		Wenn t an der Stelle r gleich '/' ist, dann:
			[ empty path element ]
			Erhöhe r um 1. [skip /]
		Wenn aber t an der Stelle r gleich '.' ist und (r gleich n ist oder t an der Stelle (r plus 1) gleich '/' ist), dann:
			[ . element ]
			Erhöhe r um 1. [skip .]
		Wenn aber t an der Stelle r gleich '.' ist und t an der Stelle (r plus 1) gleich '.' ist und (r plus 1 gleich n ist oder t an der Stelle (r plus 2) gleich '/' ist), dann:
			[ .. element: remove last / ]
			Erhöhe r um 2. 
			Wenn die Länge von path größer als, oder dotdot ist, dann:
				Mache:
					Wenn die Länge von path gleich 1 ist, dann:
						Speichere "" in path.
					Sonst
						Speichere path bis zum (die Länge von path minus 1). Element in path.
				Solange die Länge von path größer als dotdot ist und path an der Stelle (die Länge von path minus 1) ungleich '/' ist.
			Wenn aber rooted gleich falsch ist, dann:
				[ cannot backtrack, but not rooted, so append .. element ]
				Wenn die Länge von path größer als 0 ist, dann:
					Füge '/' an path an.
				Füge ".." an path an.
				Speichere die Länge von path in dotdot.
		Sonst:
			[ add slash if needed ]
			Wenn rooted und die Länge von path ungleich 1 ist oder nicht rooted und die Länge von path ungleich 0 ist, dann:
				Füge '/' an path an.

			Solange r kleiner als, oder n ist und t an der Stelle r ungleich '/' ist, mache:
				Füge (t an der Stelle r) an path an.
				Erhöhe r um 1.

	Wenn path leer ist, speichere "." in path.
	Gib path zurück.
Und kann so benutzt werden:
	"der Pfad <t> gesäubert"

[
	Verbindet zwei UNIX Pfade mit einem '/' und säubert zuletzt.
]
Die öffentliche Funktion Verbinden mit den Parametern a und b vom Typ Text und Text, gibt einen Text zurück, macht:
	Wenn a leer ist, gib b zurück.
	Wenn b leer ist, gib a zurück.
	Gib der Pfad (a verkettet mit '/' verkettet mit b) gesäubert zurück.
Und kann so benutzt werden:
	"die Pfade <a> und <b> verbunden"

[
	Pfade Terminologie:

	Beispiel: "/home/admin/data/test.tar.gz"

	Vollständiger Pfad: "/home/admin/data/test.tar.gz"
	Ordnerpfad: "/home/admin/data"
	Basisname: "test.tar.gz"
	Dateiname: "test"
	Erweiterung: "tar.gz"
]

[
	Nimmt einen Relativen Pfad t und gibt den vollständigen absoluten Pfad zurück.
]
Die öffentliche Funktion VollständigerPfad mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Der Text cwd ist der Arbeitsverzeichnis.
	Gib die Pfade cwd und t verbunden zurück.
Und kann so benutzt werden:
	"den absoluten Pfad zu <t>",
	"der absoluten Pfad zu <t>"

[
	Gibt den Pfad ohne das letze Element zurück. 
	Falls der Pfad leer ist, wird ein "." zurück gegeben.
	Falls der Pfad nur aus "/" gefolg von nicht-"/" Zeichen, wird "/" zurückgegeben.

	f("/a/b/c") = "/a/b"
	f("a/b/c") = "a/b"
	f("/a/") = "/a"
	f("a/") = "a"
	f("a") = "."
	f("/") = "/"
	f("..") = "."
	f(".") = "."
	f("") = "."
]
Die öffentliche Funktion Ordnerpfad mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Die Zahl i ist die Länge von t.
	
	Solange i größer als 0 ist, mache:
		Wenn t an der Stelle i gleich '/' ist, dann:
			Der Text dir ist t bis zum i. Element.
			Entferne alle '/' nach dir.
			Wenn die Länge von dir gleich 0 ist, gib "/" zurück.

			Gib dir zurück.
		Verringere i um 1.
	Gib "." zurück.
Und kann so benutzt werden:
	"den Ordnerpfad von <t>",
	"der Ordnerpfad von <t>"

[
	Gibt den letzten Element eines Pfades zurück. Falls der Pfad leer ist, wird "." ausgegeben.

	f("/a/b/c/d.png") = "d.png"
	f("/a/b/c/d") = "d"
	f("/a/b/c/") = "c"
	f("/a/b/c///") = "c"
	f("./b") = "b"
	f("hi.txt") = "hi.txt"
	f(".") = "."
	f("..") = ".."
	f("") = "."
]
Die öffentliche Funktion Basisname mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Der Text t2 ist (t mit allen '/' danach entfernt).
	Die Zahl i ist die Länge von t2.
	Wenn t2 gleich "" ist, gib "." zurück.
	Solange i größer als 0 ist, mache:
		Wenn t2 an der Stelle i gleich '/' ist, verlasse die Schleife.
		Verringere i um 1.
	Gib t2 ab dem (i plus 1). Element zurück.
Und kann so benutzt werden:
	"den Basisnamen von <t>",
	"der Basisname von <t>"

[
	Gibt den Dateinamen einer Datei zurück. Wenn der Pfad nicht im Format von '*/*.*' ist wird ein leerer Text zurück gegeben.

	f("/a/b/c/test.txt") = "test"
	f("/a/b/c/test.txt.exe") = "test"
	f("test.exe") = "test"
	f("/a/b/c/") = ""
	f("/a/b/c") = ""
	f("/") = ""
	f(".") = ""
	f("..") = ""
	f("noext") = ""
	f("") = ""
]
Die öffentliche Funktion Datei_Name mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Die Zahl i ist die Länge von t.
	Die Zahl ende ist -1.
	Solange i größer als 0 ist, mache:
		Wenn t an der Stelle i gleich '.' ist, speichere i minus 1 in ende.
		Wenn t an der Stelle i gleich '/' ist, verlasse die Schleife.
		Verringere i um 1.
	Wenn ende kleiner als 1 ist, gib "" zurück.
	Gib t im Bereich von i plus 1 bis ende zurück.
Und kann so benutzt werden:
	"den Dateinamen von <t>",
	"der Dateiname von <t>"

[
	Gibt die Erweiterung einer Datei zurück. Wenn der Pfad eines Ordners gegeben wurde, die Datei bei dem Pfad keine Erweiterung hat 
	oder der Parameter t leer ist, wird einen leeren Text zurück gegeben.

	f("/a/b/c/bar.css") = "css"
	f("/a/b/c/foo.tar.gz") = "tar.gz"
	f("bar.css") = "css"
	f("/a/b.trap/c/noext") = ""
	f("/") = ""
	f(".") = ""
	f("..") = ""
	f("noext") = ""
	f("") = ""
]
Die öffentliche Funktion Erweiterung mit dem Parameter t vom Typ Text, gibt einen Text zurück, macht:
	Die Zahl i ist die Länge von t.
	Die Zahl extStart ist i.
	Solange i größer als 0 ist, mache:
		Wenn t an der Stelle i gleich '/' ist, verlasse die Schleife.
		Wenn t an der Stelle i gleich '.' ist, speichere i plus 1 in extStart.
		Verringere i um 1.
	Wenn extStart größer als, oder die Länge von t ist, gib "" zurück.
	Gib t ab dem extStart. Element zurück.
Und kann so benutzt werden:
	"die Erweiterung der Datei bei <t>"