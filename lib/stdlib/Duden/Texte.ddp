Binde "Duden/Zeichen" ein.

[
	Gibt "" zurück.
	Nutzen: Der Text t ist ein leerer Text.
]
Die öffentliche Funktion LeererText gibt einen Text zurück, macht:
	Gib "" zurück.
Und kann so benutzt werden:
	"ein leerer Text" oder
	"einen leeren Text"

[
	Entfernt alle gegebenen Buchstaben vom Anfang eines gegebenen Textes.
	z.B.: 
		Der Text t ist "aaaaaaahallo"
		Entferne alle 'a' vor t.
		t: "hallo"
]
Die öffentliche Funktion TrimAnfang mit den Parametern text und zeichen vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Wenn die Länge von text gleich 0 ist, verlasse die Funktion.
	Die Zahl index ist 1.
	Solange (text an der Stelle index) gleich zeichen ist, erhöhe index um 1.
	Speichere text von index bis (die Länge von text) in text.
Und kann so benutzt werden:
	"Entferne alle <zeichen> vor <text>"

[
	Siehe TrimAnfang
]
Die öffentliche Funktion TrimAnfangWert mit den Parametern text und zeichen vom Typ Text und Buchstabe, gibt einen Text zurück, macht:
	Entferne alle zeichen vor text.
	Gib text zurück.
Und kann so benutzt werden:
	"<text> mit allen <zeichen> davor entfernt"

[
	Entfernt alle gegebenen Buchstaben vom Ende eines gegebenen Textes.
	z.B.: 
		Der Text t ist "hallo!!!!!!!!!!"
		Entferne alle '!' nach t.
		t: "hallo"
]
Die öffentliche Funktion TrimEnde mit den Parametern text und zeichen vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Die Zahl index ist die Länge von text.
	Wenn index gleich 0 ist, verlasse die Funktion.
	Solange (text an der Stelle index) gleich zeichen ist, mache:
		Verringere index um 1.
		Wenn index kleiner als 1 ist, dann:
			Speichere "" in text.
			Verlasse die Funktion.

	Speichere text von 1 bis index in text.
Und kann so benutzt werden:
	"Entferne alle <zeichen> nach <text>"

[
	Siehe TrimEnde
]
Die öffentliche Funktion TrimEndeWert mit den Parametern text und zeichen vom Typ Text und Buchstabe, gibt einen Text zurück, macht:
	Entferne alle zeichen nach text.
	Gib text zurück.
Und kann so benutzt werden:
	"<text> mit allen <zeichen> danach entfernt"

[
	Entfernt alle gegebenen Buchstaben vom Anfang und Ende eines gegebenen Textes.
	z.B.: 
		Der Text t ist "!!!!!hallo!!!!!!!!!!"
		Entferne alle '!' vor und nach t.
		t: "hallo"
]
Die öffentliche Funktion Trim mit den Parametern text und zeichen vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Die Zahl startIndex ist 1.
	Die Zahl stopIndex ist die Länge von text.
	Solange (text an der Stelle startIndex) gleich zeichen ist, erhöhe startIndex um 1.
	Solange (text an der Stelle stopIndex) gleich zeichen ist, verringere stopIndex um 1.
	Speichere text von startIndex bis stopIndex in text.
Und kann so benutzt werden:
	"Entferne alle <zeichen> vor und nach <text>"

[
	Siehe Trim
]
Die öffentliche Funktion TrimWert mit den Parametern text und zeichen vom Typ Text und Buchstabe, gibt einen Text zurück, macht:
	Entferne alle zeichen vor und nach text.
	Gib text zurück.
Und kann so benutzt werden:
	"<text> mit allen <zeichen> davor und danach entfernt"

[
	Gibt zurück ob der gegebenen Text den gegebenen Buchstaben enthält. 
]
Die öffentliche Funktion EnthältBuchstabe mit den Parametern text und zeichen vom Typ Text und Buchstabe, gibt einen Boolean zurück, macht:
	Für jeden Buchstaben b in text, wenn b gleich zeichen ist, gib wahr zurück.
	Gib falsch zurück.
Und kann so benutzt werden:
	"<text> <zeichen> enthält"

[
	Gibt zurück ob der gegebene Text (text) den Subtext (suchText) enthält.
]
Die öffentliche Funktion EnthältText mit den Parametern text und suchText vom Typ Text und Text, gibt einen Boolean zurück, macht:
	Die Zahl startIndex ist 0.
	Die Zahl endIndex ist die Länge von suchText.

	Solange endIndex kleiner als, oder die Länge von text ist, mache:
		Der Text subtext ist text von startIndex bis endIndex.

		Wenn subtext gleich suchText ist, gib wahr zurück.
		
		Speichere startIndex plus die Länge von suchText in endIndex.
		Erhöhe startIndex um 1.
	Gib falsch zurück.
Und kann so benutzt werden:
	"<text> <suchText> enthält"

[
	Gibt zurück ob der gegebene Text mit dem gegebenen Buchstaben anfängt.
]
Die öffentliche Funktion BeginntMitBuchstabe mit den Parametern text und buchstabe vom Typ Text und Buchstabe, gibt einen Boolean zurück, macht:
	Wenn die Länge von text gleich 0 ist, gib falsch zurück.
	Gib (text an der Stelle 1) gleich buchstabe ist zurück.
Und kann so benutzt werden:
	"<buchstabe> am Anfang von <text> steht"

[
	Gibt zurück ob der gegebene Text mit dem gegebenen Text (suchText) anfängt.
]
Die öffentliche Funktion BeginntMitText mit den Parametern text und suchText vom Typ Text und Text, gibt einen Boolean zurück, macht:
	Gib (text von 1 bis (die Länge von suchText)) gleich suchText ist zurück.
Und kann so benutzt werden:
	"<suchText> am Anfang von <text> steht"

[
	Gibt zurück ob der gegebene Text mit dem gegebenen Buchstaben endet.
]
Die öffentliche Funktion EndetMitBuchstabe mit den Parametern text und buchstabe vom Typ Text und Buchstabe, gibt einen Boolean zurück, macht:
	Wenn die Länge von text gleich 0 ist, gib falsch zurück.
	Gib (text an der Stelle (die Länge von text)) gleich buchstabe ist zurück.
Und kann so benutzt werden:
	"<buchstabe> am Ende von <text> steht"

[
	Gibt zurück ob der gegebene Text mit dem gegebenen Text (suchText) endet.
]
Die öffentliche Funktion EndetMitText mit den Parametern text und suchText vom Typ Text und Text, gibt einen Boolean zurück, macht:
	Gib (text von die Länge von text minus die Länge von suchText plus 1 bis (die Länge von text)) gleich suchText ist zurück.
Und kann so benutzt werden:
	"<suchText> am Ende von <text> steht"

[
	Speichert einen leeren Text in text.
]
Die öffentliche Funktion Text_leeren mit dem Parameter text vom Typ Text Referenz, gibt nichts zurück, macht:
	Speichere "" in text.
Und kann so benutzt werden:
	"Leere <text>"

[
	Fügt zwei Texte aneinander.
	f("ha", "lo") -> "halo"
]
Die öffentliche Funktion Text_an_Text_fügen mit den Parametern text und elm vom Typ Text Referenz und Text, gibt nichts zurück, macht:
	Speichere text verkettet mit elm in text.
Und kann so benutzt werden:
	"Füge <elm> an <text> an"

[
	Fügt einen Buchstaben an einen Text.
	f("may", 'o') -> "mayo"
]
Die öffentliche Funktion Buchstabe_an_Text_fügen mit den Parametern text und elm vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Speichere text verkettet mit elm in text.
Und kann so benutzt werden:
	"Füge <elm> an <text> an"

[
	Fügt einen Text 
]
Die öffentliche Funktion Text_in_Text_einfügen mit den Parametern text, index und elm vom Typ Text Referenz, Zahl und Text, gibt nichts zurück, macht:
	Speichere text von 1 bis (index minus 1) verkettet mit elm verkettet mit text von index bis (die Länge von text) in text.
Und kann so benutzt werden:
	"Setze <elm> an die Stelle <index> von <text>"

Die öffentliche Funktion Buchstabe_in_Text_einfügen mit den Parametern text, index und elm vom Typ Text Referenz, Zahl und Buchstabe, gibt nichts zurück, macht:
	Speichere text von 1 bis (index minus 1) verkettet mit elm verkettet mit text von index bis (die Länge von text) in text.
Und kann so benutzt werden:
	"Setze <elm> an die Stelle <index> von <text>"

[
	Fügt einen Text am Anfang eines Textes ein.
	f("hallo", " welt!") -> "hallo welt!"
]
Die öffentliche Funktion Text_vor_Text_stellen mit den Parametern text und elm vom Typ Text Referenz und Text, gibt nichts zurück, macht:
	Speichere elm verkettet mit text in text.
Und kann so benutzt werden:
	"Stelle <elm> vor <text>"

[
	Fügt einen Buchstaben am Anfang eines Textes ein.
	f("allo", 'h') -> "hallo"
]
Die öffentliche Funktion Buchstabe_vor_Text_stellen mit den Parametern text und elm vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Speichere elm verkettet mit text in text.
Und kann so benutzt werden:
	"Stelle <elm> vor <text>"

[
	Entfernt den Buchstaben an der Stelle index vom Text
]
Die öffentliche Funktion Lösche_Text mit den Parametern text und index vom Typ Text Referenz und Zahl, gibt nichts zurück, macht:
	Wenn die Länge von text gleich 0 ist, verlasse die Funktion.

	Wenn index gleich 1 ist und die Länge von text größer als 1 ist, dann:
		Speichere "" in text.
	Wenn aber index gleich 1 ist, dann:
		Speichere text von 2 bis (die Länge von text) in text.
	Wenn aber index gleich die Länge von text ist, dann:
		Speichere text von 1 bis (die Länge von text minus 1) in text.
	Sonst:
		Speichere text von 1 bis (index minus 1) verkettet mit text von (index plus 1) bis (die Länge von text) in text.
Und kann so benutzt werden:
	"Lösche das Element an der Stelle <index> aus <text>"

[
	Entfernt einen Bereich vom Text
]
Die öffentliche Funktion Lösche_Text_Bereich mit den Parametern text, start und end vom Typ Text Referenz, Zahl und Zahl, gibt nichts zurück, macht:
	Wenn start gleich 1 ist, dann:
		Speichere text von end plus 1 bis (die Länge von text) in text.
	Sonst:
		Speichere text von 1 bis (start minus 1) verkettet mit text von (end plus 1) bis (die Länge von text) in text.
Und kann so benutzt werden:
	"Lösche alle Elemente von <start> bis <end> aus <text>"

[
	Füllt den Text mit dem gegebenen Buchstaben
]
Die öffentliche Funktion Fülle_Text mit den Parametern text und elm vom Typ Text Referenz und Buchstabe, gibt nichts zurück, macht:
	Der Text neuerText ist "".
	Wiederhole:
		Speichere neuerText verkettet mit elm in neuerText.
	Die Länge von text Mal.

	Speichere neuerText in text.
Und kann so benutzt werden:
	"Fülle <text> mit <elm>"

[
	Gibt den index des gegebenen Buchstaben im Text zurück oder -1 falls es nicht gefunden wurde. 
]
Die öffentliche Funktion IndexVonText mit den Parametern text und elm vom Typ Text und Buchstabe, gibt eine Zahl zurück, macht:
	Wenn die Länge von text gleich 0 ist, gib -1 zurück.
	Für jede Zahl i von 1 bis (die Länge von text), Wenn text an der Stelle i gleich elm ist, gib i zurück.
	Gib -1 zurück.
Und kann so benutzt werden:
	"der Index von <elm> in <text>" oder
	"den Index von <elm> in <text>"

[
	Gibt ob der gegebene Text leer ist zurück
]
Die öffentliche Funktion IstTextLeer mit dem Parameter text vom Typ Text, gibt einen Boolean zurück, macht:
	Gib [wahr wenn] die Länge von text gleich 0 ist zurück.
Und kann so benutzt werden:
	"<text> leer ist"

[
	Gibt zurück ob ein Text in eine Zahl umgewandelt werden kann
]
Die öffentliche Funktion Ist_Zahl mit dem Parameter t vom Typ Text, gibt einen Boolean zurück, macht:
	Die Zahl l ist die Länge von t.
	Wenn l kleiner als 1 ist, gib falsch zurück.

	Der Buchstabe Vorzeichen ist t an der Stelle 1.
	Wenn Vorzeichen eine Zahl ist, gib wahr zurück.
	Wenn Vorzeichen ungleich '+' ist und Vorzeichen ungleich '-' ist, gib falsch zurück.
	Wenn l kleiner als 2 ist oder nicht (t an der Stelle 2) eine Zahl ist, gib falsch zurück.
	Gib wahr zurück.
Und kann so benutzt werden:
	"<t> eine Zahl ist"

[
	Wandelt jeden Buchstaben des gegebenen Textes in die groß geschriebene Variante
]
Die öffentliche Funktion GroßschreibenWert mit dem Parameter text vom Typ Text, gibt einen Text zurück, macht:
	Der Text neuerText ist "".
	Für jeden Buchstaben b in text, mache:
		Füge (b als großer Buchstabe) an neuerText an.
	Gib neuerText zurück.
Und kann so benutzt werden:
	"<text> groß geschrieben"

[
	Wandelt jeden Buchstaben des gegebenen Textes in die groß geschriebene Variante
]
Die öffentliche Funktion Großschreiben mit dem Parameter text vom Typ Text Referenz, gibt nichts zurück, macht:
	Speichere text groß geschrieben in text.
Und kann so benutzt werden:
	"Schreibe <text> groß"

[
	Wandelt jeden Buchstaben des gegebenen Textes in die klein geschriebene Variante
]
Die öffentliche Funktion KleinschreibenWert mit dem Parameter text vom Typ Text, gibt einen Text zurück, macht:
	Der Text neuerText ist "".
	Für jeden Buchstaben b in text, mache:
		Füge (b als kleiner Buchstabe) an neuerText an.
	Gib neuerText zurück.
Und kann so benutzt werden:
	"<text> klein geschrieben"

[
	Wandelt jeden Buchstaben des gegebenen Textes in die klein geschriebene Variante
]
Die öffentliche Funktion Kleinschreiben mit dem Parameter text vom Typ Text Referenz, gibt nichts zurück, macht:
	Speichere text klein geschrieben in text.
Und kann so benutzt werden:
	"Schreibe <text> klein"

[
	z.B.:
	f("hallo", ' ', 8) -> "   hallo"
	f("hey", ' ', 8) -> "     hey"
	f("programm", ' ', 8) -> "programm"
	f("", 'o', 8) -> "oooooooo" 
]
Die öffentliche Funktion PolsterLinks mit den Parametern text, zeichen und endlänge vom Typ Text, Buchstabe und Zahl, gibt einen Text zurück, macht:
	Die Zahl länge ist die Länge von text.
	Die Zahl gesuchteLänge ist endlänge minus länge.
	Wenn gesuchteLänge kleiner als, oder 0 ist, dann:
		Gib text zurück.
	
	Wiederhole:
		Stelle zeichen vor text.
	gesuchteLänge Mal.

	Gib text zurück.
Und kann so benutzt werden:
	"<text> mit <endlänge> <zeichen> links gepolstert"

[
	z.B.:
	f("hallo", ' ', 8) -> "hallo   "
	f("hey", ' ', 8) -> "hey     "
	f("programm", ' ', 8) -> "programm"
	f("", 'o', 8) -> "oooooooo" 
]
Die öffentliche Funktion PolsterRechts mit den Parametern text, zeichen und endlänge vom Typ Text, Buchstabe und Zahl, gibt einen Text zurück, macht:
	Die Zahl länge ist die Länge von text.
	Die Zahl gesuchteLänge ist endlänge minus länge.
	Wenn gesuchteLänge kleiner als, oder 0 ist, dann:
		Gib text zurück.
	
	Wiederhole:
		Füge zeichen an text an.
	gesuchteLänge Mal.
	
	Gib text zurück.
Und kann so benutzt werden:
	"<text> mit <endlänge> <zeichen> rechts gepolstert"

[
	Spaltet den gegebenen Text anhand des angegebenen Buchstaben in Teiltexte. 
]
Die öffentliche Funktion Spalte mit den Parametern text und zeichen vom Typ Text und Buchstabe, gibt eine Text Liste zurück, macht:
	Die Text Liste endliste ist eine leere Text Liste.
	Die Zahl endIndex ist der Index von zeichen in text.
	Solange endIndex ungleich -1 ist und endIndex ungleich die Länge von text ist, mache:
		Wenn endIndex ungleich 1 ist, dann:
			Speichere endliste verkettet mit text von 1 bis (endIndex minus 1) in endliste.
			Speichere text von endIndex plus 1 bis (die Länge von text) in text.
		Sonst:
			Speichere endliste verkettet mit "" in endliste.
			Speichere text von 2 bis (die Länge von text) in text.
		Speichere der Index von zeichen in text in endIndex.
	
	Speichere endliste verkettet mit text in endliste.
	Gib endliste zurück.
Und kann so benutzt werden:
	"<text> an <zeichen> gespalten"

[
	Two-Way string-matching Algorithmus
]

[Die Funktion maxSuf mit den Parametern x, m und p vom Typ Text, Zahl und Zahlen Referenz, gibt eine Zahl zurück, macht:
	Die Zahl ms ist -1.
	Die Zahl j ist 0.
	Die Zahl k ist 1.
	Speichere 1 in p.

	Solange j plus k kleiner als m ist, mache:
		Der Buchstabe a ist x an der Stelle (j plus k).
		Der Buchstabe b ist x an der Stelle (ms plus k).
		Wenn a als Zahl kleiner als b als Zahl ist, dann:
			Erhöhe j um k.
			Speichere 1 in k.
			Speichere j minus ms in p.
		Sonst:
			Wenn a gleich b ist, dann:
				Wenn k ungleich p ist, erhoehe k um 1.
				Sonst:
					Erhöhe j um p.
					Speichere 1 in k.
			Sonst:
				Speichere j in ms.
				Speichere ms plus 1 in j.
				Speichere 1 in p.
				Speichere 1 in k.
	Gib ms zurück.
Und kann so benutzt werden:
	"maxSuf(<x>, <m>, <p>)"

Die Funktion maxSufTilde mit den Parametern x, m und p vom Typ Text, Zahl und Zahlen Referenz, gibt eine Zahl zurück, macht:
	Die Zahl ms ist -1.
	Die Zahl j ist 0.
	Die Zahl k ist 1.
	Speichere 1 in p.

	Solange j plus k kleiner als m ist, mache:
		Der Buchstabe a ist x an der Stelle (j plus k).
		Der Buchstabe b ist x an der Stelle (ms plus k).
		Wenn a als Zahl größer als b als Zahl ist, dann:
			Erhöhe j um k.
			Speichere 1 in k.
			Speichere j minus ms in p.
		Sonst:
			Wenn a gleich b ist, dann:
				Wenn k ungleich p ist, erhoehe k um 1.
				Sonst:
					Erhöhe j um p.
					Speichere 1 in k.
			Sonst:
				Speichere j in ms.
				Speichere ms plus 1 in j.
				Speichere 1 in p.
				Speichere 1 in k.
	Gib ms zurück.
Und kann so benutzt werden:
	"maxSufTile(<x>, <m>, <p>)"

Binde max aus "Duden/Mathe" ein.
Binde Schreibe_Text aus "Duden/Ausgabe" ein.

Die öffentliche Funktion TW mit den Parametern x, m, y und n vom Typ Text, Zahl, Text und Zahl, gibt nichts zurück, macht:
	Die Zahl p ist 0.
	Die Zahl q ist 0.
	Die Zahl ell ist 0.
	Die Zahl per ist 0.

	Die Zahl i ist maxSuf(x, m, p).
	Die Zahl j ist maxSufTile(x, m, q).

	Wenn i größer als j ist, dann:
		Speichere i in ell.
		Speichere p in per.
	Sonst:
		Speichere j in ell.
		Speichere q in per.
	
	Wenn (x von 1 bis (ell plus 1)) gleich (x von per bis (per plus ell plus 1)) ist, dann:
		Speichere 0 in j.
		Die Zahl memory ist -1.
		Solange j kleiner als, oder n minus m ist, mache:
			Speichere (die größere Zahl von ell und memory) plus 1 in i.
			Solange i kleiner als m ist und x an der Stelle i gleich y an der Stelle (i plus j) ist, erhoehe i um 1.
			Wenn i größer als, oder m ist, dann:
				Speichere ell in i.
				Solange i größer als memory ist und x an der Stelle i gleich y an der Stelle (i plus j) ist, verringere i um 1.
				Wenn i kleiner als, oder memory ist, dann:
					Schreibe ("p: " verkettet mit p als Text verkettet mit ", q: " verkettet mit q als Text verkettet mit ", i: " verkettet mit i als Text verkettet mit ", j: " verkettet mit j als Text).
				Erhoehe j um per.
				Speichere m minus per minus 1 in memory.
			Sonst:
				Erhöhe j um i minus ell.
				Speichere -1 in memory.
	Sonst:
		Speichere (die größere Zahl von (ell plus 1) und (m minus ell minus 1)) plus 1 in per.
		Speichere 0 in j.
		Solange j kleiner als, oder (n minus m) ist, mache:
			Speichere ell plus 1 in i.
			Solange i kleiner als m ist und x an der Stelle i gleich y an der Stelle (i plus j) ist, erhoehe i um 1.
			Wenn i größer als, oder m ist, dann:
				Speichere ell in i.
				Solange i größer als, oder 0 ist und x an der Stelle i gleich y an der Stelle (i plus j) ist, verringere i um 1.
				Wenn i kleiner als 0 ist, dann:
					Schreibe ("p: " verkettet mit p als Text verkettet mit ", q: " verkettet mit q als Text verkettet mit ", i: " verkettet mit i als Text verkettet mit ", j: " verkettet mit j als Text).
				Erhöhe j um per.
			Sonst:
				Erhöhe j um (i minus ell).
Und kann so benutzt werden:
	"TW(<x>, <m>, <y>, <n>)"
]