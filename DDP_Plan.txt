———————————————————————————————————————————————————————————————————————————————————————————————————————=[ DDP ]=———————————————————————————————————————————————————————————————————————————————————————————————————————
‖_____________ Legende _________________‖
‖	Lit. 	=> Literal vom Typ			‖
‖	() 		=> muss						‖
‖	[]		=> optional					‖
‖	|		=> oder						‖
‖	//		=> Beispiel					‖
‖	->		=> Keine DDP Syntax 		‖
‖	!		=> nicht/negierung			‖
‖	var		=> Name von Variable		‖
‖	\ 		=> Escape-Sequenzzeichen	‖
———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Anweisungen/Befehle
# Endet mit "."
# Nach einem Punkt muss der nächste Buchstabe großgeschrieben werden

——————————————————————————=[ Typen ]=——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Zahl => int64 (long)
- Kommazahl => float64 (double)
- Boolean => bool
- Buchstabe => char(16bit)
- Text => string

Ansammlungen (jeden Typs):
- Zahlen
- Kommazahlen
- Booleans
- Buchstaben
- Texte

Listen (jeden Typs):
- Zahlen Liste
- Kommazahlen Liste
- Boolean Liste
- Buchstaben Liste
- Text Liste

——————————————————————————=[ Deklaration ]=————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- Der|Die (Typ) (var) ist (Ausdruck vom Typ). // Die Zahl x ist 3.

Extra:
- Der Boolean (var) ist wahr|falsch wenn (Bedingung) ist. -> x == false 	// Der Boolean x ist wahr wenn 3 größer als 5 ist. -> x == false

Ansammlungs Deklaration:
- Die (Typ Ansammlung) (var) sind ([Aufzählung vom Typ]|[(Lit. Zahl) mal (Lit. Typ)]). // Die Zahlen x sind 1, 2 und 3. -> x == [1, 2, 3] || Die Zahlen x sind 3 mal 7 -> x == [7, 7, 7]

Listen Deklaration:
- Die (Typ Liste) (var) ist ([Aufzählung vom Typ]|[(Lit. Zahl) mal (Lit. Typ)]).					// Die Zahlen Liste x ist 1, 2, 3 und 4.


Aufzählungen:
- (Lit. Zahl), (Lit. Zahl),... und (Lit. Zahl) 					// 1, 2 und 3
- (Lit. Kommazahl), (Lit. Kommazahl),... und (Lit. Kommazahl) 	// 6,9, 4,20 und 77
- (Lit. Boolean), (Lit. Booleand (Lit. Boolean) 				// wahr, falsch, wahr und falsch
- (Lit. Buchstabe), (Lit. Buchstabe),... und (Lit. Buchstabe)	// 'b', 'z', 'x' und 'E'
- (Lit. Text), (Lit. Text),... und (Lit. Text) 					// "Hallo", "Welt" und "!".

Aufzählungen von Typnamen:
- ([Typname]|[(Lit. Zahl) (Typname einer Ansammlung)]), ([Typname]|[(Lit. Zahl) (Typname einer Ansammlung)]),... und ([Typname]|[(Lit. Zahl) (Typname einer Ansammlung)])

——————————————————————————=[ Zuweisung ]=——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Deklaration und Initialisierung ist vorher Notwendig
# var wurde vorher als Variable von Typ deklariert und initialisiert

# var ist eine einzelne Variable
- (var) ist (Lit. Typ). // x ist 7. -> x == 7
- Speichere das Ergebnis von (Ausdruck vom Typ) in (var vom Typ !Boolean).	// Speichere das Ergebnis von 5 mal 5 durch 5 in x. -> x == 5
- Speichere (Ausdruck vom Typ) in (var vom Typ !Boolean).

(var vom Typ Boolean) ist (wahr|falsch|[(wahr|falsch) wenn (Ausdruck vom Typ Boolean) ist]).

# var ist eine Ansammlung
- (var) sind (Aufzählung vom Typ und selber Größe wie bei Deklaration). // x sind 1, 2 und 3 -> x == [1, 2, 3]
- Speichere das Ergebnis von (Ausdruck vom Typ und selber Größe wie bei Deklaration) in (var).

# var ist eine Liste
- (var) sind (Aufzählung vom Typ). // x sind 1, 2 und 3 -> x == [1, 2, 3]
- Speichere das Ergebnis von (Ausdruck vom Typ) in (var).


Mathematische Zuweisungen:
- Addiere (var vom Typ Zahl|Kommazahl) mit (var|Lit. Zahl|Kommazahl) und speichere das Ergebnis in (var|anderervar). 
- Erhöhe (var vom Typ Zahl|Kommazahl) um (var|Lit. Zahl|Kommazahl).

- Subtrahiere (var vom Typ Zahl|Kommazahl) mit (var|Lit. Zahl|Kommazahl) und speichere das Ergebnis in (var|anderervar). 
- Verringere (var vom Typ Zahl|Kommazahl) um (var|Lit. Zahl|Kommazahl).

- Multipliziere (var vom Typ Zahl|Kommazahl) mit (var|Lit. Zahl|Kommazahl) und speichere das Ergebnis in (var|anderervar). 
- Vervielfache (var vom Typ Zahl|Kommazahl) um (var|Lit. Zahl|Kommazahl).

- Dividiere (var vom Typ Zahl|Kommazahl) mit (Lit. Zahl|Kommazahl) und speichere das Ergebnis in (var|anderervar). 
- Teile (var vom Typ Zahl|Kommazahl) durch (Lit. Zahl|Kommazahl).



Spezielle Zuweisungen:
# Ansammlungen und Listen fangen von 1 an.

# x = [0, 7, 9, 34]
- (var vom Typ Ansammlung|Liste|Text) an der Stelle (Ausdruck vom Typ Zahl) ist (Lit. Ansammlungstyp|Listentyp). // x an der Stelle 2 ist 7. -> x[2] == 7
- Speichere das Ergebnis von (Ausdruck vom Typ von Ansammlung|Liste|Text) in (var) an der Stelle (Ausdruck vom Typ Zahl). // Speichere das Ergebnis von 1 plus 1 in x an der Stelle 2. -> x[2] == 2

(var vom Typ Booleanansammlung|Booleanliste) an der Stelle (Lit. Zahl) ist (wahr|falsch|[(wahr|falsch) wenn (Ausdruck vom Typ Boolean) ist]). // x an der Stelle 0 ist wahr wenn 2 größer als 1 ist. -> x == true

# Text fängt auch bei 1 an.

# x = "hallo"
- Füge (Ausdruck vom Typ Text|Buchstabe) an (var vom Typ Text) an. // Füge "abc" an x an. -> x == "halloabc"
- Füge (Ausdruck vom Typ Text|Buchstabe) in (var vom Typ Text) an die Stelle (Ausdruck vom Typ Zahl) ein. // Füge "abc" in x an die Stelle 3 ein. -> x == "hallabco"
- Stelle (Ausdruck vom Typ Text|Buchstabe) vor (var vom Typ Text). // Stelle "abc" vor x. -> x == "abchallo".
- Lösche den Buchstaben an der Stelle (Ausdruck vom Typ Zahl) aus dem Text (Ausdruck vom Typ Text).
- Lösche alle Buchstaben von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) aus dem Text (Ausdruck vom Typ Text).
- Ersetze im Text (var vom Typ Text) (Ausdruck vom Typ Text|Buchstabe) mit (Ausdruck vom Typ Text|Buchstabe). // Ersetze im Text x "lo" mit "t Stop" -> x = "Halt Stop"
- Entferne alle (Lit. Buchstabe|Text) vor (var vom Typ Text)
- Entferne alle (Lit. Buchstabe|Text) nach (var vom Typ Text)
- Spalte (var Text) am Seperator ','

# x = 5.
- Verschiebe (var vom Typ Zahl) um (Ausdruck vom Typ Zahl) Bit nach (links|rechts). // Verschiebe x um 4 Bit nach links. -> x = 80
- Negiere (var vom Typ Zahl|Boolean). // Negiere x. -> x = -6

- Speichere die Länge von (var|[Lit. Text|Ansammlung|Liste]) in (var).
- Speichere die Größe von (var|Lit.) in (var).
- Speichere den (sinus|kosinus|tangens|arkussinus|arkuskosinus|arkustangens|hyperbelsinus|hyperbelkosinus|hyperbeltangens) von (Ausdruck vom Typ Zahl|Kommazahl) in (var vom Typ Kommazahl)
- Speichere die (Lit. Zahl). Wurzel von (Ausdruck vom Typ Zahl|Kommazahl) in (var vom Typ Kommazahl).

# die Elementtypen der Listen müssen übereinstimmen
# x = [1, 2, 3]
- Füge (Ausdruck vom Typ der Liste) an (var vom Typ Liste) an. // Füge 69 an x an. -> x == [1, 2, 3, 69]
- Setze (Ausdruck vom Typ der Liste) an die Stelle (Ausdruck vom Typ Zahl) von (var vom Typ Liste). // Setze 69 an die Stelle 2 von x. -> x == [1, 69, 2, 3]
- Setze die Elemente in (Ausdruck vom Typ Liste) an die Stelle (Ausdruck vom Typ Zahl) von (var vom Typ Liste). // x = [1, 2, 3], y = [4, 5, 6] Setze y an die Stelle 2 von x. x == [1, 4, 5, 6, 2, 3]
- Stelle (Ausdruck vom Typ der Liste) vor (var vom Typ Liste). // Stelle 69 vor x. -> x == [69, 1, 2, 3]

# alle parameter inklusiv
- Lösche das Element an der Stelle (Ausdruck vom Typ Zahl) aus (var vom Typ Liste). // Lösche das Element an der Stelle 2 aus x. -> x = [1, 3]
- Lösche alle Elemente von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) aus (var vom Typ Liste). // Lösche alle Elemente von 1 bis 2 aus x. -> x == [3]

- Leere (var vom Typ Liste). // Leere x. -> x == []


——————————————————————————=[ Operatoren ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

plus, minus, mal, durch, modulo, hoch, wurzel von, natürlicher logarithmus von, Betrag von, logarithmus mit der basis (Lit. Zahl) von,
sinus, kosinus, tangens, arkussinus, arkuskosinus, arkustangens, hyperbelsinus, hyperbelkosinus, hyperbeltangens
lsft, rsft, logisch und, logisch oder, logisch kontra, logisch nicht,
gleich, ungleich, kleiner, größer, größer gleich, kleiner gleich,
und, oder, nicht,
die Länge von (Lit. Text|Ansammlung|Liste), 																		# Anzahl der Buchstaben in einem Text oder der Elemente in einer Ansammlung oder Liste
die Größe von (var|Lit.|einer Zahl|einer Kommazahl|einem Boolean|einem Text|einem Buchstabe|Struktur Name)			# Größe des Typs in Byte
(Ausdruck vom Typ Ansammlung|Liste|Text) von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) 					# Der Rückgabetyp entspricht dem Typ des ersten Ausdrucks
(Ausdruck vom Typ Ansammlung|Liste|Text) an der Stelle (Ausdruck vom Typ Zahl)										# Der Rückgabetyp entspricht dem Typ der Liste/Ansammlung oder ist ein Buchstabe
(Ausdruck vom Typ Ansammlung|Liste|Text) (Ausdruck vom Typ von Ansammlung|Text) enthält.

Konstanten:
pi, e, tau, phi

——————————————————————————=[ Bedingung ]=——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

(Ausdruck vom Typ Boolean) // 2 gleich 2 || 2 gleich 2 und 5 gleich 5
(var) [nicht] wahr|falsch // x wahr

Verzweigungen:
Wenn|Falls (Bedingung) ist, dann:
    (Anweisungen).
Wenn aber (Bedingung) ist, dann:
	(Anweisungen).
Sonst|Andernfalls|Ansonsten:
    (Anweisungen).


Wenn|Falls (Bedingung) ist, (Anweisung).
Wenn aber (Bedingung) ist, (Anweisung).
Sonst|Andernfalls|Ansonsten (Anweisung).

——————————————————————————=[ Schleifen ]=——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Kopfgesteuert:
Solange (Bedingung) ist, mache:
	(Anweisungen).

Solange (Bedingung) ist, (Anweisung).


Zählende:
# Initialisiert Name mit dem ersten Ausdruck und addiert Schrittgröße (Standartwert 1) solange bis Name den Wert des zweiten Ausdrucks erreicht hat.
# von-bis ist inklusiv.
Für jede Zahl (Name) von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) [mit Schrittgröße (Ausdruck vom Typ Zahl)], mache:
	(Anweisungen).

Für jede Zahl (Name) von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) [mit Schrittgröße (Ausdruck vom Typ Zahl)], (Anweisung).


Iterierende:
# Wertet den Ausdruck einmal aus und iteriert über jeden Buchstaben darin

Für jeden Buchstaben (Name) in (Ausdruck vom Typ Text), mache:
	(Anweisungen).

Für jeden Buchstaben (Name) in (Ausdruck vom Typ Text), (Anweisung).


# Iteriert über jedes Element im Ausdruck. Sollte sich ein bereits iteriertes Element ändern wird dies nicht berücksichtigt
Für jede[n] (AnsmmlungsTyp) (Name) in (Ausdruckom Typ Ansammlung), mache:
	(Anweisungen).
	
Für jede[n] (AnsmmlungsTyp) (Name) in (Ausdruck vom Typ Ansammlung), (Anweisung).


# Iteriert über jedes Element im Ausdruck vom Typ Liste. Sollte sich die Größe der Liste während des Iterierens ändern wird dies nicht berücksichtigt
Für jede[n] (ListenTyp) (Name) in (Ausdruck vom Typ Liste), mache:
	(Anweisungen).

Für jede[n] (ListenTyp) (Name) in (Ausdruck vom Typ Liste), (Anweisung).

——————————————————————————=[ Funktionen ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Funktionsdeklaration:
# Funktionen werden immer mit einem Alias deklariert, der angibt wie die Funktion aufgerufen wird

Die Funktion (Name) [mit den Parametern (Aufzählung von Namen) vom Typ (Aufzählung von Typnamen),] gibt ([nichts]|[eine[n]] (Typname)|[(Lit. Zahl) (Typname einer Ansammlung)]) zurück und macht:
	(Anweisungen).
und kann so benutzt werden:
	(Funktionsalias)[,
	(Funktionsalias),... oder
	(Funktionslias)]

Funktionsalias:
# Ein Funktionsalias ist ein Text Literal
# *n => parameter an der Stelle n 
# Es sind alle Alphanumerische zeichen und folgende sonderzeichen erlaubt: ä ö ü ß ! ? , . :

# Beispiel:
	Die Funktion f mit den Parametern x vom Typ Zahl, gibt nichts zurück und macht:
		Schreibe x.
	und kann so benutzt werden:
		"gib *1 aus",
		"schreie *1" oder
		"drucke *1"

Funktionsrückgabe:
Gib (Ausdruck vom Rückgabetyp) zurück. // gib 4 zurück. # wenn Rückgabetyp = Zahl ist

——————————————————————————=[ Datei Einbindungen ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Jede Datei darf nur ein mal eingebunden werden.
- Binde (Lit. Text) ein. // binde "Datei 2" ein. -> der Inhalt von Datei 2 wird in diese Zeile kopiert, falls Datei 2 nicht schon eingebunden wurde
# Man kann Relative Dateipfade verwenden: binde "../test" ein || binde "Ordner/test" ein

——————————————————————————=[ Typkonvertierungen ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

- (Ausdruck) als (Typname) // "15" als Zahl -> 15

# Zahl -> Kommazahl (auch implizit)
# Zahl -> Text
# Zahl -> Boolean (0 = falsch, nicht 0 = wahr)
# Zahl -> Buchstabe (ascii wert)
# Kommazahl -> Zahl (trunkiert)
# Kommazahl -> Text
# Boolean -> Zahl (falsch = 0, wahr = 1)
# Text -> Zahl
# Text -> Kommazahl
# Text -> Buchstaben
# Buchstabe -> Zahl (ascii wert)
# Buchstabe -> Text
# Buchstaben -> Text

# Ansammlung -> Liste (auch implizit)
# Liste -> Ansammlung
# Buchstaben Liste -> Text

# Ansammlung -> Ansammlung anderen Typs (gleiche Regeln wie oben)
# Liste -> Liste anderen Typs (gleiche Regeln wie oben)


——————————————————————————=[ Strukturen ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Struktur definition:
	Die Struktur (Strukturname) beschreibt:
		(Eigenschaftsdefinition)[,
		(Eigenschaftsdefinition),... und
		(Eigenschaftsdefinition)
		]
	und kann so erstellt werden:
		(Struktur Alias)


Eigenschaftsdefinition:
- der|die (Typname) (var) mit Standardwert (Lit. Typ). // die Zahl x mit Standardwert 4.
- die (Typname einer Ansammlung|Liste) (var) mit den Standardewerten (Aufzählung vom Ansammlungstyp). // die Zahlen t mit den Standardwerten 1, 2 und 3.

Eigenschaftszugriff:
(Eigendschaft) von (var). // x von vektor.

Struktur-Alias:
# Ein Struktur-Alias ist ein Text Literal
# *n => parameter an der Stelle n
# Es sind alle Alphanumerische zeichen und folgende sonderzeichen erlaubt: ä ö ü ß ! ? , . :

Struktur Deklarationen:
- Die (Strukturname) Struktur (var) ist (Struktur-Alias|var2). // Die Vektor2 Struktur vec ist ein neuer Vektor2.
- Die (Strukturname) Struktur (var) ist das Ergebnis von (Ausdruck vom Typ Struktur). // Die Vektor2 Struktur vec ist das Ergebnis von NestedStruct von struct1.
- Die (Strukturname) Strukturen (var) sind (Lit. Aufzählung vom Typ Struktur). // Die Vektor2 Strukturen vec sind ein neuer Vektor2, eine neuer Vektor2 und eine neuer Vektor2.
- Die (Strukturname) Strukturen Liste (var) ist (Lit. Aufzählung vom Typ Struktur). // Die Vektor2 Strukturen Liste vec sind 

# Beispiel:
	Die Struktur Vektor2 beschreibt:
		die Zahl x mit Standardwert 0 und
		die Zahl y mit Standardwert 0
	und kann so erstellt werden:
		"der Nullvektor",
		"ein neuer Vektor2" und
		"ein neuer Vektor2 mit x: *1 und y: *2".

——————————————————————————=[ Kommentare ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

\[[kommentar als Text]\]
# Kommentare können auch über mehrere Zeile gehen:
// [ 
//	 Diese Funktion macht bla bla bla.
//	 Sie gibt einen Text aus.
// ]

——————————————————————————=[ GoTo ]=———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Extrem schwer zu implementieren

Springe zu der Zeile (Lit. Zahl)

——————————————————————————=[ Eingebaute Befehle ]=—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Konsolen IO:
Schreibe die Zahl (Ausdruck von Typ Zahl). // Schreibe die Zahl 5. -> output: 5
Schreibe die Zahl (Ausdruck von Typ Zahl) auf eine Zeile. // Schreibe die Zahl 5 auf eine Zeile. -> output: 5\n

Schreibe die Kommazahl (Ausdruck von Typ Kommazahl). // Schreibe die Kommazahl 1,6. -> output: 1,6
Schreibe die Kommazahl (Ausdruck von Typ Kommazahl) auf eine Zeile. // Schreibe die Kommazahl 1,6 auf eine Zeile. -> output: 1,6\n

Schreibe den Text (Ausdruck von Typ Text). // Schreibe den Text "hallo". -> output: Hallo
Schreibe den Text (Ausdruck von Typ Text) auf eine Zeile. // Schreibe den Text "hallo" auf eine Zeile. -> output: Hallo\n

Schreibe den Buchstaben (Ausdruck von Typ Buchstabe). // Schreibe den Buchstaben 'f'. -> output: f
Schreibe den Buchstaben (Ausdruck von Typ Buchstabe) auf eine Zeile. // Schreibe den Buchstaben 'f' auf eine Zeile. -> output: f\n

Schreibe den Boolean (Ausdruck von Typ Boolean). // Schreibe den Boolean wahr. -> output: wahr
Schreibe den Boolean (Ausdruck von Typ Boolean) auf eine Zeile. // Schreibe den Boolean wahr auf eine Zeile. -> output: wahr\n

# auch noch alle Ansammlungstypen und alle Listentypen (ich hab kein bock mehr)

Überspringe eine Zeile. // Nächste Zeile. -> output: \n

die nächste Benutzereingabe // der Text t ist die nächste Benutzereingabe.
die nächste Taste // der Buchstabe b ist die nächste Taste.


Datei IO:

die Datei (Ausdruck vom Typ Text) existiert.

# für alle Typen
Schreibe die Zahl (Ausdruck vom Typ Zahl) in die Datei (Ausdruck vom Typ Text).
Füge die Zahl (Ausdruck vom Typ Zahl) der Datei (Ausdruck vom Typ Text) hinzu.

Schreibe die Bytes (Ausdruck vom Typ Zahlen Liste) in die Datei (Ausdruck vom Typ Text).
Füge die Bytes (Ausdruck vom Typ Zahlen Liste) der Datei (Ausdruck vom Typ Text) hinzu.

der Inhalt der Datei (Ausdruck vom Typ Text)
die Bytes der Datei (Ausdruck vom Typ Text)


Zeit:
das heutige Datum. // Die Zahlen datum sind das heutige Datum -> datum = [29, 12, 2021] 	# Tag, Monat, Jahr
die momentane Uhrzeit. //Die Zahlen zeit sind die momentane Uhrzeit -> zeit = [16, 8, 50] 	# Sekunde, Minute, Stunde
die vergange Zeit seit Programmstart in Millisekunden. // Die Zahl x ist die Zeit seit Programmstart. ->  x = 374829
Warte (Ausdruck vom Typ Zahl) Millisekunden. // warte 500 Millisekunden.
Warte (Ausdruck vom Typ Zahl) Sekunden. // warte 5 Sekunden.
Warte (Ausdruck vom Typ Zahl) Minuten. // warte 30 Minuten.


Zufall:
# Alle parameter inklusiv (bedeutet das beim Beispiel 1, 10 und alles dazwischen zurück gegeben werden kann)

eine Zufällige Zahl von (Ausdruck vom Typ Zahl) bis (Ausdruck vom Typ Zahl) // die Zahl x ist eine Zufällige Zahl von 1 bis 10. -> x = 5
eine Zufällige Kommazahl von (Ausdruck vom Typ Kommazahl) bis (Ausdruck vom Typ Kommazahl) // die Kommazahl x ist eine Zufällige Kommazahl von 0 bis 1,0. -> x = 0.34



Kontrolle:
Beende das Programm. # Environment.Exit(0);
Warte auf die nächste Benutzereingabe. # ReadKey()

——————————————————————————=[ Beispiele ]=——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Fizzbuzz
für jede Zahl i von 1 bis 100, mache:
	wenn i modulo 3 gleich 0 und i modulo 5 gleich 0 ist, dann:
		schreibe den Text "FizzBuzz" auf eine Zeile.
	sonst:
		wenn i modulo 3 gleich 0 ist, dann:
			schreibe den Text "Fizz" auf eine Zeile.
		wenn aber i modulo 5 gleich 0 ist, dann:
			schreibe den Text "Buzz" auf eine Zeile.
		sonst:
			schreibe die Zahl i auf eine Zeile.



# Fibonacci
Die Funktion fib mit den Parametern n vom Typ Zahl, gibt eine Zahl zurück und macht:
	wenn n kleiner als, oder 1 ist, dann:
        Gib n zurück.

    Gib die (n minus 2). Fibonacci nummer plus die (n minus 1). Fibonacci nummer zurück.
und kann so benutzt werden:
	"die *1. Fibonacci nummer"

Die Zahl num ist die 5. Fibonacci nummer.
Schreibe die Zahl num.



# Tic Tac Toe
Die Buchstaben brett sind 9 mal ' '.
Der Boolean Spieler1 ist wahr.

Die Funktion zeichneBrett gibt nichts zurück und macht:
	für jede Zahl i von 1 bis 9, mache:
		Schreibe den Buchstaben brett an der Stelle i.
		Schreibe den Buchstaben ' '.
		wenn i modulo 3 gleich 0 ist, dann überspringe eine Zeile.
und kann so benutzt werden:
	"Zeichne das Brett"

Die Funktion überprüfe mit den Parametern spieler vom Typ Buchstabe, gibt einen Boolean zurück und macht:
	wenn brett an der Stelle 1 gleich spieler und brett an der Stelle 2 gleich spieler und brett an der Stelle 3 gleich spieler ist, dann gib wahr zurück.
	wenn brett an der Stelle 4 gleich spieler und brett an der Stelle 5 gleich spieler und brett an der Stelle 6 gleich spieler ist, dann gib wahr zurück.
	wenn brett an der Stelle 7 gleich spieler und brett an der Stelle 8 gleich spieler und brett an der Stelle 9 gleich spieler ist, dann gib wahr zurück.

	wenn brett an der Stelle 1 gleich spieler und brett an der Stelle 4 gleich spieler und brett an der Stelle 7 gleich spieler ist, dann gib wahr zurück.
	wenn brett an der Stelle 2 gleich spieler und brett an der Stelle 5 gleich spieler und brett an der Stelle 8 gleich spieler ist, dann gib wahr zurück.
	wenn brett an der Stelle 3 gleich spieler und brett an der Stelle 6 gleich spieler und brett an der Stelle 9 gleich spieler ist, dann gib wahr zurück.

	wenn brett an der Stelle 1 gleich spieler und brett an der Stelle 5 gleich spieler und brett an der Stelle 9 gleich spieler ist, dann gib wahr zurück.
	wenn brett an der Stelle 3 gleich spieler und brett an der Stelle 5 gleich spieler und brett an der Stelle 7 gleich spieler ist, dann gib wahr zurück.

	gib falsch zurück.
und kann so benutzt werden:
	"Spieler *1 gewonnen hat"


Der Buchstabe eingabe ist die nächste Taste.
solange eingabe ungleich 'v' ist, mache:
	Die Zahl feld ist eingabe als Zahl.
	wenn brett an der Stelle feld gleich ' ' ist, dann:
		wenn Spieler1 gleich wahr ist, dann:
			brett an der Stelle feld ist 'X'.
		sonst:
			brett an der Stelle feld ist 'O'.
	sonst:
		solange brett an der Stelle feld ungleich ' ' ist, mache:
			Schreibe den Text "Dieses Feld ist bereits belegt, gib ein anderes ein: ".
			eingabe ist die nächste Benutzereingabe.
			feld ist eingabe als Zahl.
			Überspringe eine Zeile.

		wenn Spieler1 gleich wahr ist, dann:
			brett an der Stelle feld ist 'X'.
		sonst:
			brett an der Stelle feld ist 'O'.
	
	wenn Spieler 'X' gewonnen hat, dann:
		Schreibe den Text "Spieler 1 hat gewonnen".
		Warte auf die nächste Benutzereingabe.
		Beende das Programm.
	wenn aber Spieler 'O' gewonnen hat, dann:
		Schreibe den Text "Spieler 2 hat gewonnen".
		Warte auf die nächste Benutzereingabe.
		Beende das Programm.
	wenn aber nicht brett ' ' enthält, dann:
		Schreibe den Text "Unentschieden".
		Warte auf die nächste Benutzereingabe.
		Beende das Programm.

	Zeichne das Brett.
	Negiere Spieler1.
	eingabe ist die nächste Taste.
